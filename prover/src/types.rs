use human_index_lib::{HumanIndexPublicInputs, VerificationResults};
use serde::{Deserialize, Serialize};

/// Request message received from Pub/Sub
/// Contains both private inputs (VerificationResults) and public inputs (HumanIndexPublicInputs)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProverRequest {
    /// Unique request ID for tracking
    pub request_id: String,

    /// Private inputs: verification results that will be proven
    pub verification_results: VerificationResults,

    /// Public inputs: weights and expected output
    pub public_inputs: HumanIndexPublicInputs,
}

/// Response message to be published to result topic
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProverResponse {
    /// Request ID from the original request
    pub request_id: String,

    /// Status of the proof generation
    pub status: ProofStatus,

    /// Proof data if successful
    #[serde(skip_serializing_if = "Option::is_none")]
    pub proof_data: Option<ProofData>,

    /// Error information if failed
    #[serde(skip_serializing_if = "Option::is_none")]
    pub error: Option<ProofError>,

    /// Metrics about the proof generation process
    #[serde(skip_serializing_if = "Option::is_none")]
    pub metrics: Option<ProofMetrics>,
}

/// Status of proof generation
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(rename_all = "lowercase")]
pub enum ProofStatus {
    Success,
    Failed,
    Timeout,
}

/// Proof data generated by the prover
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProofData {
    /// Base64-encoded proof bytes
    pub proof: String,

    /// Base64-encoded public inputs
    pub public_inputs: String,

    /// Base64-encoded verification key
    pub verification_key: String,

    /// Calculated human index output
    pub human_index: u32,
}

/// Error information when proof generation fails
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProofError {
    /// Error type/code
    pub error_type: String,

    /// Human-readable error message
    pub message: String,

    /// Optional stack trace or additional details
    #[serde(skip_serializing_if = "Option::is_none")]
    pub details: Option<String>,
}

/// Metrics about the proof generation process
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProofMetrics {
    /// When the request was received (ISO 8601 timestamp)
    pub received_at: String,

    /// When proof generation started (ISO 8601 timestamp)
    pub started_at: String,

    /// When proof generation completed (ISO 8601 timestamp)
    pub completed_at: String,

    /// Total duration in milliseconds
    pub duration_ms: u64,

    /// Whether Groth16 setup was needed
    pub setup_required: bool,
}

impl ProverResponse {
    /// Create a successful response
    pub fn success(
        request_id: String,
        proof_data: ProofData,
        metrics: ProofMetrics,
    ) -> Self {
        Self {
            request_id,
            status: ProofStatus::Success,
            proof_data: Some(proof_data),
            error: None,
            metrics: Some(metrics),
        }
    }

    /// Create a failed response
    pub fn failed(
        request_id: String,
        error: ProofError,
        metrics: Option<ProofMetrics>,
    ) -> Self {
        Self {
            request_id,
            status: ProofStatus::Failed,
            proof_data: None,
            error: Some(error),
            metrics,
        }
    }

    /// Create a timeout response
    pub fn timeout(
        request_id: String,
        message: String,
        metrics: Option<ProofMetrics>,
    ) -> Self {
        Self {
            request_id,
            status: ProofStatus::Timeout,
            proof_data: None,
            error: Some(ProofError {
                error_type: "Timeout".to_string(),
                message,
                details: None,
            }),
            metrics,
        }
    }
}